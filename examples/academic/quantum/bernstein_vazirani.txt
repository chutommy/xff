https://iopscience.iop.org/article/10.1088/1367-2630/18/8/083030/meta#back-to-top-target
Abstract
Using trapped ion quantum bits in a scalable microfabricated surface trap, we perform the Bernstein–Vazirani algorithm. Our architecture takes advantage of the ion transport capabilities of such a trap. The algorithm is demonstrated using two- and three-ion chains. For three ions, an improvement is achieved compared to a classical system using the same number of oracle queries. For two ions and one query, we correctly determine an unknown bit string with probability 97.6(8)%. For three ions, we succeed with probability 80.9(3)%.

Export citation and abstract BibTeX RIS

Previous article in issue
Next article in issue
1. Introduction
The Bernstein–Vazirani (BV) algorithm helped to solidify the potential promise of quantum computers. The algorithm was the first example of a quasi-polynomial speed-up over a probabilistic classical computer [1, 2]. In this work, we demonstrate this elementary quantum algorithm with trapped ion qubits. With three qubits and one oracle query we can determine a hidden two-bit string with higher fidelity than the 50% success rate of a classical algorithm. The experiment relies upon the precision ion transport possible in a microfabricated trap. Our work may serve as a blueprint for one node in a larger quantum system based upon ion transport [3].

The goal of the BV algorithm is to determine a secret string $s\in \{0,1\}{}^{n}$. We are given access to an oracle which adds $s\cdot x$ (mod 2) to an ancilla bit a, where x is a user provided n-bit string. One can solve the classical version of the problem by querying the oracle n times with $x={2}^{i},i\in \{0,1,\ldots ,n-1\}$. By examining the value of a after each run, the user can determine the ith bit of s. However, using the BV quantum algorithm, s can be determined with one oracle query. By bracketing the oracle query with Hadamard transformations and preparing a = 1 to generate a phase kickback [4], the action of the oracle on the ancilla results in the bits of s being mapped onto the bits in x. To determine s, one need only measure the state of the data qubits (the ancilla qubit is returned to the $| 1\rangle $ state). The algorithm provides a polynomial speed-up by a factor of n for a single string s. It can achieve a quasi-polynomial speed-up for the recursed problem [5].

The circuit for the BV algorithm, shown in figure 1(a), contains the standard motif of a classical oracle transformed by Hadamard gates. Up to the oracle, this is the same blueprint used for Deutsch and Jozsa's quantum algorithm and a key component of Grover's search algorithm [4]. If the input Hadamard gate on the ancilla qubit is not performed, the circuit can be used to solve the learning parity with noise problem [6, 7].

 Zoom In Zoom Out Reset image size
Figure 1. (a) Circuit diagram for the BV algorithm. The bits of s are mapped to the data bits xi and can be determined in a single run of the algorithm. (b) Our implementation of the BV algorithm with three ions. The ancilla qubit is in the center of the three-ion chain. The oracle is implemented via two cnot gates. The execution of these gates is conditioned on the classical bits in s.

Download figure:

 Standard image High-resolution image
To implement the BV algorithm, we require an oracle that can perform the unitary


where ⊕ is addition modulo 2. We build this oracle from a series of cnot gates acting on the ancilla qubit and each data qubit xi, as shown for n = 2 in figure 1(b). The ancilla qubit is the target bit in each cnot. To implement the dot product between s and x, the application of each cnot is conditioned on the classical bits in s, i.e. we only perform a cnot between xi and a if ${s}_{i}=1$.

2. Experiment overview
We demonstrate the BV algorithm using a chain of 171Yb+ ions in a microfabricated surface trap. The trap is described in [8] and further details on 171Yb+ trapping can be found in [9]. In this system, single ions are sequentially loaded and then merged into a common harmonic well to build a chain of the desired length.

Following [10, 11], gates are performed via a Raman transition using a mode-locked, tripled YAG laser with a 355 nm wavelength and a repetition rate of ${\nu }_{r}=$ 119.12(1) MHz. Pairs of comb teeth separated by $106\times {\nu }_{r}$ span the 12.6 GHz qubit hyperfine splitting ${\nu }_{0}$, such that ${\nu }_{0}\,=(106\times {\nu }_{r})+{\rm{\Delta }}$. The necessary correction frequency, ${\rm{\Delta }}\simeq 16\,\mathrm{MHz}$, changes with drifts in ${\nu }_{r}$. To monitor this, we measure the beat between combteeth spaced by $14\times {\nu }_{r}$. We feed this signal forward to an acousto-optic modulator (AOM) to add $(200+{\rm{\Delta }})$ MHz to one of our counter-propagating Raman beams. A second AOM shifts the frequency of the other Raman beam by 200 MHz for resonant carrier interactions and by small offsets from 200 MHz to address motional modes.

While quantum algorithms have already been performed in three dimensional ion traps [12–16], this is the first demonstration in a microfabricated planar trap. The use of microfabrication permits scaling to larger algorithm demonstrations by enabling repeatable production of many electrodes for ion transport, as well as integration of detection optics [17] and control electronics [18]. These features will prove useful for implementing many-ion quantum systems [3, 19].

Universal control over the ion chain is accomplished by addressing ions pairwise, as described in [20]. Briefly, we transport the ion chain between a set of discrete gate locations. At each location, the gate lasers are pulsed on, and one pair of ions is illuminated. Entanglement is provided by nearest-neighbor Mølmer–Sørensen (MS) interactions [21]. To generate independent single qubit unitaries, we perform a cascade: a unitary operation at each successive gate location across the chain. Each unitary is composed of PB1-stabilized $\pi /2$ rotations ${R}_{\varphi }(\pi /2)$, where φ labels the axis of rotation in the equatorial plane of the Bloch sphere. The PB1 passband compensating sequence serves to alleviate amplitude errors on the two targeted ions and suppress rotations on the others [22–24]. We have built a compiler that finds a minimum set of rotations to construct a desired single qubit unitary. Additionally, the compiler compacts requested single qubit gates into one unitary while accounting for previous operations in the cascade.

While we employ the same beam geometry as [20], system improvements have led to the increased gate fidelities reported in table 1. The principal improvement is to propagate one arm of our Raman beam pair through a segment of photonic crystal fiber [25]. Improved mode quality out of the fiber nearly halves the crosstalk during pairwise MS gates on three ions. This is exemplified by the population in $| 1\rangle $ of the unaddressed ion after Bell state preparation (P1 in table 1). In addition to the fiber, we upgraded our compiler to track off-resonant light shifts caused by each Raman beam. Both of these upgrades are described in appendix A. In appendix B, we discuss the effect of phase noise from imperfect tracking of ${\nu }_{r}$. We believe that this is the primary error source in our single qubit operations.

Table 1.  Percentage gate fidelities for two- and three-ion chains. Single qubit (SQ) Clifford gate fidelities are characterized via randomized benchmarking [26]. MS fidelities are characterized according to the following procedure: all ions are prepared in the $| 0\rangle $ state, a pairwise MS gate is performed, and then a parity measurement. We report the fidelity of Bell state creation (${F}_{\mathrm{Bell}}$) following the methods in [27]. We also report P1, the unwanted $| 1\rangle $ population in the untargeted ion, to indicate the level of crosstalk during MS gates.

Chain length	Gate type	Ion 0	Ion 1	Ion 2
2	SQ	97.80(6)	98.47(5)	—
3	SQ	97.4(1)	97.9(1)	98.6(1)
 	 	Target pair	${F}_{\mathrm{Bell}}$	P1
2	MS	01	96.1(8)	—
3	MS	01	89.6(9)	5.2(3)
3	MS	12	83.1(1.0)	10.2(6)
3. Algorithm implementation
Each implementation of the algorithm begins with Doppler cooling and Raman sideband cooling. After cooling, we measure an average temperature of ${\bar{n}}_{\mathrm{COM}}=0.6(1)$ quanta in the radial center of mass (COM) mode. All other radial modes are cooled to an average temperature below 0.1 quanta. The ions are then initialized to $| {0}^{\otimes n+1}\rangle $ via optical pumping. We follow this with a cascade of single qubit rotations to Hadamard transform each data qubit to $| +\rangle =\tfrac{1}{\sqrt{2}}(| 0\rangle +| 1\rangle )$ and the ancilla to $| -\rangle =\tfrac{1}{\sqrt{2}}(| 0\rangle -| 1\rangle )$. In the three-ion case, the ancilla qubit is the middle ion of the chain to allow for nearest-neighbor MS gates, as shown in figure 2. To separate the input state preparation from the oracle implementation, these preparation gates are not compiled into any subsequent gates.

 Zoom In Zoom Out Reset image size
Figure 2. (a) Circuit diagram for a three-ion implementation of the BV algorithm. The algorithm is broken up into four sections. The state preparation and analysis pulses are shown in the two yellow boxes. Conditional cnot gates carry out the function of the oracle. Each cnot contains a phase corrected MS gate, discussed in section 3. Gate operations in each section are compiled to reduce the total number of operations. However, gates across sections are not compiled. (b) Schematic of pairwise addressing for the compiled BV. Each purple bar represents a PB1-stabilized $\pi /2$ pulse operation about an axis φ in the equatorial plane. Curved purple bars indicate operations where only one ion on the end of the chain is addressed.

Download figure:

 Standard image High-resolution image
To apply the oracle operation, cnot gates are performed between each data ion and the ancilla, conditioned on the value of s. cnot gates are built from MS gates with particular single qubit rotations before and after, as shown in figure 2(a). Due to increased axial confinement used during MS gates [20], we sample a different phase of our Raman beams than during single qubit gate operations. To negate this frame shift, we add phase corrections ${R}_{z}({\varphi }_{a,b})$ and ${R}_{z}(-{\varphi }_{a,b}-{\varphi }_{r})$ to our compiled algorithm. The phase ${\varphi }_{r}$ accounts for light shifts (see appendix A) accumulated during the MS gate. To accommodate these phase shifts in the fewest number of physical $\pi /2$ rotations, we insert optimization gates O(φ), where φ is a free parameter in the gate compilation. As described in [20], the addition of these gates still produces the desired cnot.

cnot gates need to be turned on and off conditioned on the bits in s. If ${s}_{i}=0$, all the transport associated with each gate is performed, however the gate lasers are not turned on. This ensures algorithm honesty, as we do not optimize for any particular value of s. Each cnot block is compiled separately from all other algorithm sections so that it can be turned on or off without effecting the rest of the circuit.

The oracle is followed by Hadamard gates on each ion and individual-ion state detection. In total, the algorithm takes 3.9 ms for two ions and 9.8 ms for three ions. The two-ion algorithm employs nine transport operations, and the three-ion algorithm requires nineteen. Each adiabatic transport is performed in 100 μs.

4. Algorithm output
To compare the BV algorithm to its classical counterpart, one can imagine that the user is given access to one classical query of the oracle which provides the value of a single bit in s. Then he or she must guess the remaining bits. Thus, for an n-bit secret string s, the user will guess the string correctly with probability ${2}^{-n+1}$. We implement the BV quantum algorithm for n = 1, 2 and provide state detection results in figure 3.

 Zoom In Zoom Out Reset image size
Figure 3. (a) State populations after BV implementation on a two ion chain for different oracle inputs s. The expected state $| s\rangle \otimes | 1\rangle $ is marked in red. Values listed are the percentage occupation for the two states where s was marked correctly, regardless of the state of the ancilla. (b) Three ion implementation with s containing two bits. With the ancilla in the center of the chain the expected output state is now $| {s}_{0}\rangle \otimes | 1\rangle \otimes | {s}_{1}\rangle $.

Download figure:

 Standard image High-resolution image
For n = 1, a classical system can determine the single bit in s correctly 100% of the time. We find a quantum success probability of 97.6(8)%, averaged over the two oracle states. This is taken by summing over the states where the data bit s is in the correct state, regardless of the state of the ancilla. In the s = 0 case, we perform six PB1-stabilized $\pi /2$ rotations. To check plausibility, we can compare our measured state populations to results from randomized benchmarking sequences of similar length. Such sequences yield the correct output state with a fidelity of 95(3)%. The quoted uncertainty corresponds to the spread of randomized benchmarking results. This matches well with the 94(1)% state fidelity reported in figure 3(a). To make the same comparison when s = 1, we must account for fifteen PB1-stabilized $\pi /2$ rotations and one MS gate. By treating the error from the two gate types as uncorrelated, we expect an output state fidelity of 89(3)%. This matches the measured 94.2(8)% to within two standard deviations.

For n = 2, we correctly determine the bit string s with probability 80.9(3)%, averaged over the four oracle states. This is an improvement over the classical success rate of 50% for a single query. Furthermore, we can use information theory to determine the information gained by one run of this algorithm. We calculate the entropy reduction of one pass of the algorithm by examining the mutual information between our algorithm output x and a bit string s [13, 28]. Classically, as expected, the user gains exactly one bit of information per oracle query. Quantum mechanically we gain 1.10(3) bits of information.

In the three-qubit algorithm, our largest source of error is the MS gate on the ${\text{}}12$ pair. This gate is the lowest fidelity operation in the system and causes significant crosstalk on the untargeted ion. This manifests itself in the algorithm output as a large correlation between the $| 110\rangle $ and $| 111\rangle $ states when the gate is performed. When s = 10 there is 14.8(5)% population in the $| 111\rangle $ state, and when s = 11 there is 17.3(5)% build up in $| 110\rangle $. These populations have a drastic effect on algorithm fidelity and reduce the target output states below 80%. Preliminary work with the 'echo' decoupling technique discussed in [20] improves ${F}_{\mathrm{Bell}}$ to 87.9(1.0)% and reduces P1 to 3.4(4)%. The echo involves splitting the MS gate in half, ensuring the spin-motion entanglement is zero after each half, and inserting a Y gate on the targeted (or untargeted) ions after each half. At present, the additional errors introduced by the extra set of single qubit operations outweigh the improved decoupling. We expect that with improved single qubit operation fidelities we can incorporate this technique in our algorithm.

5. Motional heating
One concern for scaling such an architecture is motional mode excitation due to anomalous heating and ion transport. We measure an anomalous heating rate of 50(6) quanta s−1 on the COM mode. Heating on other modes is less than 7 quanta s−1. The MS two-qubit interaction and the PB1 pulse sequence were chosen to help mitigate gate errors due to increasing ion temperature. We do not believe that these errors are a current fidelity limitation.

For MS gates, we couple mainly to the rocking mode to avoid the larger anomalous heating rate of the COM mode [29]. With two ions, we detune 13 kHz from the 1.64 MHz rocking mode and 91 kHz from the 1.74 MHz COM mode. We have simulated the density matrix evolution of this MS gate, expanding the Hamiltonian out to third order in Lamb–Dicke parameter. The calculated Lamb–Dicke parameters are nearly 0.1 for both modes. Following [21], we incorporated a coupling between vibrational states and a thermal reservoir. This predicts that heating on the COM mode will cause errors on the order of 10−4 per gate.

For single qubit operations, the PB1 sequence largely alleviates the carrier Rabi rate dependence on ion temperature. Simulations of a two-ion chain indicate that we require ${\bar{n}}_{\mathrm{COM}}\geqslant 5.5$ quanta to accumulate a sizable infidelity ($\gt {10}^{-4}$) per PB1-stabilized $\pi /2$ rotation. After performing the two-ion BV algorithm with transport, but with gate lasers off, we measure ${\bar{n}}_{\mathrm{COM}}=0.9(1)$.

In a three-ion chain, we require ${\bar{n}}_{\mathrm{COM}}\geqslant 8.5$ quanta to exceed the same error threshold. The discrepancy compared to the two-ion case is due to the different Lamb–Dicke parameters. We measure ${\bar{n}}_{\mathrm{COM}}=1.6(1)$ quanta after the three-ion BV algorithm with transport. If we replace the algorithm with an equivalent delay, ${\bar{n}}_{\mathrm{COM}}$ is consistent at 1.8(1) quanta. This affirms that the nineteen transport operations, each of about $5\,\mu {\rm{m}}$, are not a significant source of additional heating.

Thus, at our current heating rate, we do not expect that increasing ion temperature contributes largely to gate infidelities during the BV algorithm. However, as fidelities improve, scaling the system up may require implementation of proven technologies to reduce the heating rate [30, 31], to transport more quickly [32], and to allow for cooling after transport [33].

6. Outlook
With nearest-neighbor cnot gates, swap operations are necessary to increase the number of data qubits beyond two. For n data qubits and the ancilla in the center of the chain, one can implement the BV algorithm using $\tfrac{1}{4}{(n-1)}^{2}$ swaps for n odd and $\tfrac{1}{4}n(n-2)$ swaps for n even, where each swap is built from three cnots. However, adding ions to the chain increases spectral crowding which can result in reduced gate fidelity. While this can be corrected for using segmented control pulses [34], chain length is likely still limited to 5–10 ions. One avenue for scaling to larger numbers of ions is to couple small chains with merge and separation operations [3, 35]. Microfabricated traps readily provide the control necessary for such precision transport and a path towards repeatable construction of connected trap arrays.

In this work, we have demonstrated a quantum algorithm in a microfabricated ion trap using transport-based ion addressing. Our three-ion implementation of the algorithm provides the user with more information than its classical counterpart. We utilized temperature-insensitive gate operations to mitigate the effects of ion-heating. By demonstrating qubit control interlaced with up to nineteen transport operations, we affirm the exceptional transport capabilities of surface electrode traps.

Acknowledgments
The authors thank J True Merrill and Adam Meier for help with numerical simulations of randomized benchmarking. This material is based upon work supported by the Office of the Director of National Intelligence (ODNI), Intelligence Advanced Research Projects Activity (IARPA) under US Army Research Office (ARO) contract W911NF1010231. All statements of fact, opinion, or conclusions contained herein are those of the authors and should not be construed as representing the official views or policies of IARPA, the ODNI, or the US Government.

Appendix A.: System improvements
We have implemented key upgrades to our system relative to the work in [20]. We now transmit one arm of our Raman beam pair through a 300 mm segment of photonic crystal fiber (LMA-PM-5, NKT Photonics) before it is focused down to the trapping region. The mounted fiber provides improved beam mode quality and reduced spatial beam wander from free space propagation of the tripled YAG laser. The output of the fiber is focused to a waist ($1/{e}^{2}$ intensity half-width) of roughly 5 μm, whereas the waist of the other arm of the Raman beam pair is 14 μm. The $1/e$ half-width of the Raman interaction is largely set by the 5 μm beam, which is slightly less than the ion spacing of the chain. Without utilizing the hydrogen loading treatment outlined in [25], we cannot propagate more than 20 mW of 355 nm light through the fiber without solarization over a few days of operation. Thus, to perform pairwise single qubit $\pi /2$ rotations in 6 μs, we send 1 mW through the fiber and 110 mW through the other free-space Raman beam. We propagate 2 mW through the fiber to implement MS gates in approximately 160 μs.

In [20], we describe errors due to imperfect overlap between the red and blue sideband beams during MS gates. This is now mitigated by propagating both sideband beams through the same fiber, improving the Bell-state fidelities between addressed ions as presented in table 1. Additionally, as mentioned in section 2, crosstalk during pairwise MS gates on three ions is nearly halved.

We also discuss errors from imperfect pairwise addressing during single qubit operations in [20]. We employed the PB1 sequence in that work, however the suppression was not sufficient to neglect population transfer on ions adjacent to the addressed pair ('neighbor ions'). With the fiber in place, the tighter beam focus and improved mode quality reduce the Rabi rate of neighbor ions to less than 20% of the addressed ions. Under these conditions, for each resonant PB1-stabilized $\pi /2$ rotation, we expect neighbor ions to experience a worst case infidelity of $1-F=7\times {10}^{-4}$ with respect to the identity operation. This suppression allows us to neglect these unwanted neighbor ion rotations in our compiled algorithm.

Carrier transitions on a pair of ions still exhibit some crosstalk with the rest of the chain. Each Raman beam can induce Raman transitions by itself due to interactions of pairs of comb teeth. The laser repetition rate was chosen such that these single-beam interactions are well detuned from the carrier transition. However, off-resonant couplings introduce a non-negligible shift in the qubit energy splitting. The magnitude of the dominant component of this light shift is ${\delta }_{{ac}}={{\rm{\Omega }}}_{{ac}}^{2}/2{\rm{\Delta }}$, where ${{\rm{\Omega }}}_{{ac}}$ is the Rabi frequency of the shifting laser field and ${\rm{\Delta }}\simeq 16\,\mathrm{MHz}$ as in section 2. In our experiment, ${{\rm{\Omega }}}_{{ac}}$ depends on an ion's location in the beam, thus we measure the shift for each ion at each gate location using Ramsey spectroscopy. For the free-space beam, we measure ∼650 Hz shifts when an ion is targeted, ∼350 Hz shifts when it is a neighbor, and ∼100 Hz shifts when it is two locations away from the target pair. Shifts due to the fiber-coupled beam are small ($\lt 60$ Hz) and localized onto the targeted ion pair.

We model the total light shift as a constant detuning during gate pulses. On target ions, the PB1 sequence corrects for the shifts well, and we expect PB1-stabilized $\pi /2$ rotation infidelities of $7\times {10}^{-5}$. For untargeted ions, the sequence cannot correct for the shift. However, the error is well approximated by a z-rotation ${R}_{z}(\phi )$, where $\phi =2\pi \delta {\tau }_{\mathrm{PB}1}$, δ is the measured frequency shift in Hz, and the time per PB1 sequence, ${\tau }_{\mathrm{PB}1}$, is 102 μs. For ions well outside of the beam, this approximation becomes exact. To incorporate these rotations in our gate compiler, anytime we perform a gate operation, we include ${R}_{z}(\phi )$ for each untargeted ion.

Appendix B.: Single qubit gate error
We believe that the primary error source for single qubit Clifford operations is phase noise in the Raman interaction due to imperfect tracking of the laser repetition rate ${\nu }_{r}$. Figure B1 shows results from numerical simulations of two-ion randomized benchmarking after fifteen Clifford operations per ion.

 Zoom In Zoom Out Reset image size
Figure B1. Simulated Clifford gate fidelity as a function of frequency of applied phase noise. Each simulation is an average over 50 randomly generated randomized benchmarking sequences, each with 15 gates per ion and a random starting phase of our noise source. In our cascading architecture, ion 0 is targeted for twice as many PB1 pulse sequences as ion 1 on average. As expected, the simulation shows that the larger number of noisy gate operations leads to a higher error rate for ion 0. The dashed lines indicate the measured randomized benchmarking fidelities for each ion in a two-ion chain.

Download figure:

 Standard image High-resolution image
To match our physical implementation, the simulations incorporate each gate laser pulse, account for hardware programming delays, and include the time for ion transport. We plot single qubit Clifford gate fidelity as a function of the frequency of an applied phase noise. The phase noise is modeled at a single frequency and with a modulation depth of 0.02 radians. Noise in the 20–60 kHz frequency range is particularly detrimental. The period of this noise (16–50 μs) is on the order of ${\tau }_{\mathrm{PB}1}$. We have observed noise near this sensitive band using the techniques described in [36]. However, technical limitations prevented us from measuring noise with frequency greater than 15 kHz. In future work, we hope to characterize and mitigate these noise sources for higher fidelity operation.
